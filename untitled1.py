# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yBMUAb1uhCr_hOlhnY88DiwCsNF8Z5NH
"""

# Cell 1: Imports and Graph class

from typing import Dict, List, Tuple, Hashable, Optional, Callable, Set
import math
import heapq
import matplotlib.pyplot as plt

Node = Hashable
Weight = float

class Graph:
    def __init__(self, directed: bool = True):
        self.directed = directed
        self.adj: Dict[Node, List[Tuple[Node, Weight]]] = {}

    def add_edge(self, u: Node, v: Node, w: Weight) -> None:
        """Add edge u -> v with weight w."""
        if u not in self.adj:
            self.adj[u] = []
        if v not in self.adj:
            self.adj[v] = []
        self.adj[u].append((v, w))
        if not self.directed:
            self.adj[v].append((u, w))

    def neighbors(self, u: Node) -> List[Tuple[Node, Weight]]:
        return self.adj.get(u, [])

    def nodes(self) -> List[Node]:
        return list(self.adj.keys())

# Cell 2: Heuristic functions

from typing import Tuple

Coord = Tuple[int, int]

def zero_heuristic(a: Coord, b: Coord) -> float:
    """Admissible but weak heuristic: h(n) = 0 (A* behaves like Dijkstra)."""
    return 0.0

def manhattan(a: Coord, b: Coord) -> float:
    """L1 distance heuristic, good for 4-neighbor grid."""
    (x1, y1), (x2, y2) = a, b
    return abs(x1 - x2) + abs(y1 - y2)

def euclidean(a: Coord, b: Coord) -> float:
    """L2 distance heuristic."""
    (x1, y1), (x2, y2) = a, b
    return math.hypot(x1 - x2, y1 - y2)

# Cell 3: Bellman-Ford algorithm

def bellman_ford(
    graph: Graph,
    source: Node
) -> Tuple[Dict[Node, float], Dict[Node, Optional[Node]], bool, int]:
    """
    Bellman-Ford shortest paths.
    Returns: (distances, predecessors, has_negative_cycle, relax_count)
    relax_count is how many times an edge was successfully relaxed
    (used as a rough measure of work).
    """
    nodes = graph.nodes()
    dist: Dict[Node, float] = {v: math.inf for v in nodes}
    pred: Dict[Node, Optional[Node]] = {v: None for v in nodes}
    dist[source] = 0.0

    relax_count = 0

    # Relax edges |V| - 1 times
    for _ in range(len(nodes) - 1):
        updated = False
        for u in nodes:
            for v, w in graph.neighbors(u):
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    pred[v] = u
                    relax_count += 1
                    updated = True
        if not updated:
            break

    # Check for negative cycle
    has_negative_cycle = False
    for u in nodes:
        for v, w in graph.neighbors(u):
            if dist[u] + w < dist[v]:
                has_negative_cycle = True

    return dist, pred, has_negative_cycle, relax_count


def reconstruct_path(
    pred: Dict[Node, Optional[Node]],
    source: Node,
    target: Node
) -> Optional[List[Node]]:
    """Reconstruct path from source to target using predecessor map."""
    if target not in pred:
        return None
    if source == target:
        return [source]
    if pred[target] is None:
        return None

    path = [target]
    while target != source:
        target = pred[target]
        if target is None:
            return None
        path.append(target)
    path.reverse()
    return path

# Cell 4: A* algorithm

Heuristic = Callable[[Node, Node], float]

def astar(
    graph: Graph,
    start: Node,
    goal: Node,
    heuristic: Heuristic
) -> Tuple[Optional[List[Node]], float, int]:
    """
    A* search.
    Returns: (path, path_cost, expanded_nodes)
    expanded_nodes: number of nodes actually popped from the open set (rough work).
    """
    open_heap: List[Tuple[float, Node]] = []
    heapq.heappush(open_heap, (0.0, start))

    g: Dict[Node, float] = {start: 0.0}  # cost from start
    f: Dict[Node, float] = {start: heuristic(start, goal)}  # estimated total
    came_from: Dict[Node, Optional[Node]] = {}

    closed: Set[Node] = set()
    expanded_nodes = 0

    while open_heap:
        _, current = heapq.heappop(open_heap)
        if current in closed:
            continue

        closed.add(current)
        expanded_nodes += 1

        if current == goal:
            # Reconstruct path
            path = [current]
            while current in came_from:
                current = came_from[current]
                path.append(current)
            path.reverse()
            return path, g[path[-1]], expanded_nodes

        for neighbor, weight in graph.neighbors(current):
            tentative_g = g[current] + weight
            if tentative_g < g.get(neighbor, math.inf):
                g[neighbor] = tentative_g
                came_from[neighbor] = current
                f[neighbor] = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_heap, (f[neighbor], neighbor))

    # No path found
    return None, math.inf, expanded_nodes

# Cell 5 (updated): Build WEIGHTED grid, run experiments, and visualization helpers

import random

def build_weighted_grid_graph(width: int, height: int,
                              w_min: int = 1, w_max: int = 5,
                              seed: int = 0) -> Graph:
    """
    Build an undirected grid graph with random positive weights.
    Each edge weight is in [w_min, w_max].
    Using only (1,0) and (0,1) directions to avoid duplicate edges.
    """
    random.seed(seed)
    g = Graph(directed=False)
    for x in range(width):
        for y in range(height):
            node = (x, y)
            for dx, dy in [(1, 0), (0, 1)]:  # right and down only; undirected graph adds back-edge
                nx, ny = x + dx, y + dy
                if 0 <= nx < width and 0 <= ny < height:
                    w = random.randint(w_min, w_max)
                    g.add_edge(node, (nx, ny), float(w))
    return g


def run_experiments(width: int = 25, height: int = 25):
    """
    Run A* with different heuristics + Bellman-Ford on a weighted grid,
    print stats, and return results for plotting.
    """
    start = (0, 0)
    goal = (width - 1, height - 1)

    graph = build_weighted_grid_graph(width, height, w_min=1, w_max=5, seed=42)

    heuristics = [
        ("zero (Dijkstra-style)", zero_heuristic),
        ("Manhattan", manhattan),
        ("Euclidean", euclidean),
    ]

    astar_results = []

    print("=== A* with different heuristics (weighted grid) ===")
    for name, h in heuristics:
        path, cost, expanded = astar(graph, start, goal, h)
        astar_results.append({
            "name": name,
            "heuristic": h,
            "path": path,
            "cost": cost,
            "expanded": expanded,
        })
        print(f"Heuristic: {name}")
        print(f"  Path cost: {cost}")
        print(f"  Path length: {len(path) if path is not None else 'no path'}")
        print(f"  Nodes expanded: {expanded}")
        print()

    print("=== Bellman-Ford (single-source, weighted grid) ===")
    dist, pred, neg_cycle, relax_count = bellman_ford(graph, start)
    path_bf = reconstruct_path(pred, start, goal)
    bf_info = {
        "name": "Bellman-Ford",
        "path": path_bf,
        "cost": dist.get(goal, math.inf),
        "expanded": relax_count,   # use relax_count as 'work'
        "negative_cycle": neg_cycle,
    }

    print(f"Negative cycle detected? {neg_cycle}")
    print(f"Path cost: {bf_info['cost']}")
    print(f"Path length: {len(path_bf) if path_bf is not None else 'no path'}")
    print(f"Relaxations (as work measure): {relax_count}")

    meta = {
        "width": width,
        "height": height,
        "start": start,
        "goal": goal,
    }
    return astar_results, bf_info, meta


def plot_paths(astar_results, bf_info, meta):
    """
    Visualize paths on the grid:
    - A* with one heuristic (Euclidean if available)
    - Bellman-Ford path
    """
    width = meta["width"]
    height = meta["height"]

    # Pick Euclidean A*, or fallback to the first one
    chosen = None
    for r in astar_results:
        if r["name"].startswith("Euclidean"):
            chosen = r
            break
    if chosen is None:
        chosen = astar_results[-1]

    plt.figure()
    # Plot all grid nodes as background
    xs = []
    ys = []
    for x in range(width):
        for y in range(height):
            xs.append(x)
            ys.append(y)
    plt.scatter(xs, ys, s=5)

    # Plot A* path
    if chosen["path"] is not None:
        px = [p[0] for p in chosen["path"]]
        py = [p[1] for p in chosen["path"]]
        plt.plot(px, py, marker='o', label=f"A* ({chosen['name']})")

    # Plot Bellman-Ford path
    if bf_info["path"] is not None:
        bx = [p[0] for p in bf_info["path"]]
        by = [p[1] for p in bf_info["path"]]
        plt.plot(bx, by, marker='x', linestyle='--', label="Bellman-Ford")

    plt.title("Paths found by A* and Bellman-Ford on a weighted grid")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.gca().invert_yaxis()  # Optional for more 'grid-like' look
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()


def plot_expanded_nodes(astar_results, bf_info):
    """Bar chart: how much work each algorithm/heuristic does."""
    names = [r["name"] for r in astar_results] + [bf_info["name"]]
    values = [r["expanded"] for r in astar_results] + [bf_info["expanded"]]

    plt.figure()
    positions = list(range(len(names)))
    plt.bar(positions, values)
    plt.xticks(positions, names, rotation=30, ha="right")
    plt.ylabel("Work (nodes expanded / relaxations)")
    plt.title("Search effort vs heuristic / algorithm (weighted grid)")
    plt.tight_layout()
    plt.show()


def plot_path_costs(astar_results, bf_info):
    """Bar chart: compare path cost."""
    names = [r["name"] for r in astar_results] + [bf_info["name"]]
    values = [r["cost"] for r in astar_results] + [bf_info["cost"]]

    plt.figure()
    positions = list(range(len(names)))
    plt.bar(positions, values)
    plt.xticks(positions, names, rotation=30, ha="right")
    plt.ylabel("Path cost")
    plt.title("Path cost for different heuristics / algorithms (weighted grid)")
    plt.tight_layout()
    plt.show()

# Cell 6 (updated): Run experiments on weighted grid and show charts

astar_results, bf_info, meta = run_experiments(width=25, height=25)

# Path visualization (A* vs Bellman-Ford)
plot_paths(astar_results, bf_info, meta)

# Heuristic effect: how many nodes expanded / relaxations
plot_expanded_nodes(astar_results, bf_info)

# Heuristic effect: path cost comparison
plot_path_costs(astar_results, bf_info)